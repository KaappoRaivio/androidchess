package kaappo.androidchess.askokaappochess;public class movevalue{	String sSeq;	String sRoute;		int iPieceBalance;	int iCoverageBalance;	int iPawnAdvBalance;		int iProtThreatDiff;	int iCastledDiff;	int iLODevDiff;		int iDoublePawnDiff;	int iCenterControlDiff;		boolean bWhiteCheckMate;	boolean bWhiteChecked;	boolean bWhiteBlocked;		boolean bBlackCheckMate;	boolean bBlackChecked;	boolean bBlackBlocked;		int iMaxWhiteThreat;	int iMaxBlackThreat;		int iMaxWhiteThrProtBal;	int iMaxBlackThrProtBal;		int iKingCtrlDiff;	int iEGPenDiff;	int iKingSpaceDiff;		int iFreePawnPointBal;		boolean bEndGameMode;	boolean bKillModeQRwK;	boolean bPawnPromRace;		int iKingDistanceBal;		int iPieceBalCorrWhite;	int iPieceBalCorrBlack;		int iValSumWhite;	int iValSumBlack;		int iFreePawnCtrlBal;		int iMoveCount;		int iWhiteCastlingMove;	int iBlackCastlingMove;		int iCheckMoveBal;		int iMoveListLenghtBal;	int iQESBal;		boolean bWhiteInstWin;	boolean bBlackInstWin;		int iInstWinCorr;		boolean bWhiteRiskOn;	boolean bBlackRiskOn;		int iKnightCoupBal;	int iKnightCoupMovBal;		int iPcsInEnemyBlockBal;		int iPawnProtPenBal;		int iWhiteMvLastProm, iBlackMvLastProm;	int iPromBonWhite, iPromBonBlack;		int iKingCtrlFixBal;		int iSwapBal;	int iEGSBal;		boolean bBottom;		int iCutBranchLevel;		int iQRKillBal;		String sMessage;    	public static final int ALG_DEFAULT = 0;	public static final int ALG_AVOIDTHREAT = 1;	public static final int ALG_AVOIDTHREAT_BAL = 2;	public static final int ALG_NOKINGCTRBAL = 3;	public static final int ALG_NOLODEVPLUS = 4;	public static final int ALG_EARLYGAMEPEN = 5;	public static final int ALG_KINGSPACER = 6;	public static final int ALG_CHECKONEWAYONLY = 7;	public static final int ALG_NOFREEPAWNBALANCE = 8;	public static final int ALG_ENDGAMEMODE = 9;	public static final int ALG_ENDGAMEKILLMODE = 10;	public static final int ALG_PAWNPROMRACE = 11;	public static final int ALG_ENDGAMEDUALMODE = 12;	public static final int ALG_CTRCTRL = 13;	public static final int ALG_NEWAVOIDTHREAT_BAL = 14;	public static final int ALG_NEWAVOIDTHREAT_BAL_COMBO = 15;	public static final int ALG_CASTLE_BY_KIC = 16;	public static final int ALG_CASTLE_BY_KIC_LITE = 17;	public static final int ALG_CASTLE_BY_KIC_PLUS = 18;	public static final int ALG_CASTLE_BY_FLAG = 19;	public static final int ALG_CASTLE_BY_FLAG_MED = 20;	public static final int ALG_CASTLE_BY_FLAG_PLUS = 21;	public static final int ALG_CHECKMOVE_BAL = 22;	public static final int ALG_NO_OPT_TRAVERSE = 23;	public static final int ALG_MOVELIST_LEN = 24;	public static final int ALG_QUEEN_ESCAPE = 25;	public static final int ALG_DEEP_CHECK = 26;	public static final int ALG_OPT_TRAV_LEV1 = 27;	public static final int ALG_KNIGHT_COUP = 28;	public static final int ALG_NEW_TRAVERSE1 = 29;	public static final int ALG_NEW_TRAVERSE2 = 30;	public static final int ALG_NEW_TRAVERSE3 = 31;	public static final int ALG_NEW_TRAVERSE4 = 32;	public static final int ALG_NEW_TRAVERSE5 = 33;	public static final int ALG_NEW_ZEROBALANCE = 34;	public static final int ALG_PIECES_IN_EB = 35;	public static final int ALG_PPPBAL1 = 36;	public static final int ALG_PPPBAL2 = 37;	public static final int ALG_PPPBAL3 = 38;	public static final int ALG_ALLOW_STRATEGY = 39;	public static final int ALG_SUPER_PRUNING = 40;	public static final int ALG_SUPER_PRUNING_ZB = 41;	public static final int ALG_SUPER_PRUNING_KINGCFIX = 42;	public static final int ALG_SUPER_PRUNING_SWAPBAL = 44;	public static final int ALG_SUPER_PRUNING_LAST = 45;	public static final int ALG_NEW_TRAVERSE_LAST = 50;		public static final int ALG_GET_MIDPAWN_OPENING = 900;	public static final int ALG_GET_PAWNPRESS_OPENING = 901;	public static final int ALG_GET_FIANCHETTOPREP_OPENING = 902;	public static final int ALG_GET_BISHOPE3_OPENING = 903;	public static final int ALG_GET_F2STEP_OPENING = 904;	public static final int ALG_GET_PAWNFRONT_OPENING = 905;	public static final int ALG_GET_BACKROWROOK_OPENING = 906;	public static final int ALG_GET_KNIGHTTOMIDDLE_OPENING = 907;	public static final int ALG_GET_QUEENFIRSTMOVE_OPENING = 908;	public static final int ALG_GET_C2STEP_OPENING = 909;	public static final int ALG_GET_BISHOPF4_OPENING = 910;	public static final int ALG_FIRST_WEIRD_OPENING = ALG_GET_MIDPAWN_OPENING;	public static final int ALG_LAST_WEIRD_OPENING = ALG_GET_BISHOPF4_OPENING;	public static final int ALG_ASK_FROM_ENGINE1 = 1001;	public static final int ALG_ASK_FROM_ENGINE2 = 1002;	public static final int ALG_ASK_FROM_ENGINE3 = 1003;	public static final int ALG_ASK_FROM_ENGINE4 = 1004;	public static final int ALG_ASK_FROM_ENGINE5 = 1005;	public static final int ALG_ASK_FROM_ENGINE6 = 1006;	public static final int ALG_ASK_FROM_ENGINE7 = 1007;	public static final int ALG_ASK_FROM_ENGINE8 = 1008;	public static final int ALG_ASK_FROM_ENGINE9 = 1009;	public static final int ALG_ASK_FROM_ENGINE10 = 1010;	public static final int ALG_ASK_FROM_ABROK1 = 1021;	public static final int ALG_ASK_FROM_ABROK2 = 1022;	public static final int ALG_ASK_FROM_ABROK3 = 1023;	public static final int ALG_ASK_FROM_ABROK4 = 1024;	public static final int ALG_ANY_OKMOVE = 1097;	public static final int ALG_ASK_FROM_ENGINE_RND = 1098;	public static final int ALG_ASK_FROM_ENGINE_LAST = 1099;		public static final int DUMPMODE_LONG = 1;	public static final int DUMPMODE_SHORT = 2;		public static final int CUTBRANCH_INIT = -10;		String sDBG = "";		movevalue(	String s, int ipB, int icB, int ipaB, int iptB, int icasB, int ilodB, int idpB, int iccB, boolean bWcm, boolean bWc, 		boolean bWb, boolean bBcm, boolean bBc, boolean bBb, int iMWT, int iMBT, int iMWTB, int iMBTB, int ikcB, int iegPB, int ikSB, 		int ifppB, boolean bEGM, boolean bKMQ, boolean bPPR, int ikdb, int ipbcw, int ipbcb, int ivsw, int ivsb, int iMc, int ifpcb, int iwcm, int ibcm, int icmoB, int imllb, int iqesB, int iKCB, int iKCMB, boolean bWiW, boolean bBiW, int iIWC, boolean bWRO, boolean bBRO, int iPIEB, int iPPPB, int iWMLP, int iBMLP, int iPBW, int iPBB, int iKCFB, int iSwB, int iEGSB, int iCBL, int iQRKB)	{		sRoute = "";				sSeq = s;		iPieceBalance = ipB;		iCoverageBalance = icB;		iPawnAdvBalance = ipaB;				iProtThreatDiff = iptB;		iCastledDiff = icasB;		iLODevDiff = ilodB;			iDoublePawnDiff = idpB;		iCenterControlDiff = iccB;				bWhiteCheckMate = bWcm;		bWhiteChecked = bWc;		bWhiteBlocked = bWb;				bBlackCheckMate = bBcm;		bBlackChecked = bBc;		bBlackBlocked = bBb;				iMaxWhiteThreat = iMWT;		iMaxBlackThreat = iMBT;				iMaxWhiteThrProtBal = iMWTB;		iMaxBlackThrProtBal = iMBTB;				iKingCtrlDiff = ikcB;				iEGPenDiff = iegPB;		iKingSpaceDiff = ikSB;				iFreePawnPointBal = ifppB;				bEndGameMode = bEGM;		bKillModeQRwK = bKMQ;		bPawnPromRace= bPPR;			iKingDistanceBal = ikdb;				iPieceBalCorrWhite = ipbcw;		iPieceBalCorrBlack = ipbcb;			iValSumWhite = ivsw;		iValSumBlack = ivsb;				iMoveCount = iMc;				iFreePawnCtrlBal = ifpcb;				iWhiteCastlingMove = iwcm;		iBlackCastlingMove = ibcm;				iCheckMoveBal = icmoB;				iMoveListLenghtBal = imllb;		iQESBal = iqesB;				bWhiteInstWin = bWiW;		bBlackInstWin = bBiW;				iInstWinCorr = iIWC;				bWhiteRiskOn = bWRO;		bBlackRiskOn = bBRO;				iKnightCoupBal = iKCB;		iKnightCoupMovBal = iKCMB;				iPcsInEnemyBlockBal = iPIEB;		iPawnProtPenBal = iPPPB;				iWhiteMvLastProm = iWMLP;		iBlackMvLastProm = iBMLP;				iPromBonWhite = iPBW; 		iPromBonBlack = iPBB;				iKingCtrlFixBal = iKCFB;				iSwapBal = iSwB;		iEGSBal = iEGSB;				bBottom = false;		iCutBranchLevel = iCBL;				iQRKillBal = iQRKB;	}		movevalue (	int xk1, int yk1, int xk2, int yk2, int ipB, int icB, int ipaB, int iptB, int icasB, int ilodB, int idpB, int iccB, 		boolean bWcm, boolean bWc, boolean bWb, boolean bBcm, boolean bBc, boolean bBb, int iMWT, int iMBT, int iMWTB, int iMBTB, 		int ikcB, int iegPB, int ikSB, int ifppB, boolean bEGM, boolean bKMQ, boolean bPPR, int ikdb, int ipbcw, int ipbcb, int ivsw, 		int ivsb, int iMc, int ifpcb, int iwcm, int ibcm, int icmoB, int imllb, int iqesB, int iKCB, int iKCMB, boolean bWiW, boolean bBiW, int iIWC,boolean bWRO, boolean bBRO, int iPIEB, int iPPPB, int iWMLP, int iBMLP, int iPBW, int iPBB, int iKCFB, int iSwB, int iEGSB, int iCBL, int iQRKB)	{		sRoute = "";				sSeq = "" + (char)(xk1+64) + yk1 + (char)(xk2+64) + yk2;				iPieceBalance = ipB;		iCoverageBalance = icB;		iPawnAdvBalance = ipaB;				iProtThreatDiff = iptB;		iCastledDiff = icasB;		iLODevDiff = ilodB;			iDoublePawnDiff = idpB;		iCenterControlDiff = iccB;				bWhiteCheckMate = bWcm;		bWhiteChecked = bWc;		bWhiteBlocked = bWb;				bBlackCheckMate = bBcm;		bBlackChecked = bBc;		bBlackBlocked = bBb;				iMaxWhiteThreat = iMWT;		iMaxBlackThreat = iMBT;				iMaxWhiteThrProtBal = iMWTB;		iMaxBlackThrProtBal = iMBTB;				iKingCtrlDiff = ikcB;				iEGPenDiff = iegPB;		iKingSpaceDiff = ikSB;				iFreePawnPointBal = ifppB;				bEndGameMode = bEGM;		bKillModeQRwK = bKMQ;		bPawnPromRace= bPPR;			iKingDistanceBal = ikdb;				iPieceBalCorrWhite = ipbcw;		iPieceBalCorrBlack = ipbcb;			iValSumWhite = ivsw;		iValSumBlack = ivsb;				iFreePawnCtrlBal = ifpcb;				iWhiteCastlingMove = iwcm;		iBlackCastlingMove = ibcm;				iCheckMoveBal = icmoB;				iMoveListLenghtBal = imllb;		iQESBal = iqesB;				bWhiteInstWin = bWiW;		bBlackInstWin = bBiW;				iInstWinCorr = iIWC;				bWhiteRiskOn = bWRO;		bBlackRiskOn = bBRO;				iKnightCoupBal = iKCB;		iKnightCoupMovBal = iKCMB;				iPcsInEnemyBlockBal = iPIEB;		iPawnProtPenBal = iPPPB;				iWhiteMvLastProm = iWMLP;		iBlackMvLastProm = iBMLP;				iPromBonWhite = iPBW; 		iPromBonBlack = iPBB;				iKingCtrlFixBal = iKCFB;				iSwapBal = iSwB;				iMoveCount = iMc;		iEGSBal = iEGSB;				iCutBranchLevel = iCBL;				iQRKillBal = iQRKB;			}		movevalue (String s)	{		sRoute = "";		sSeq = s;				iPieceBalance = 0;		iCoverageBalance = 0;		iPawnAdvBalance = 0;				iProtThreatDiff = 0;		iCastledDiff = 0;		iLODevDiff = 0;			iDoublePawnDiff = 0;		iCenterControlDiff = 0;				bWhiteCheckMate = false;		bWhiteChecked = false;		bWhiteBlocked = false;				bBlackCheckMate = false;		bBlackChecked = false;		bBlackBlocked = false;				iMaxWhiteThreat = 0;		iMaxBlackThreat = 0;				iMaxWhiteThrProtBal = 0;		iMaxBlackThrProtBal = 0;				iKingCtrlDiff = 0;				iEGPenDiff = 0;		iKingSpaceDiff = 0;				iFreePawnPointBal = 0;				bEndGameMode = false;		bKillModeQRwK = false;		bPawnPromRace= false;			iKingDistanceBal = 0;				iPieceBalCorrWhite = 0;		iPieceBalCorrBlack = 0;			iValSumWhite = 0;		iValSumBlack = 0;				iMoveCount = 0;				iFreePawnCtrlBal = 0;				iWhiteCastlingMove = 0;		iBlackCastlingMove = 0;				iCheckMoveBal = 0;				iMoveListLenghtBal = 0;		iQESBal = 0;				bWhiteInstWin = false;		bBlackInstWin = false;				iInstWinCorr = 0;				bWhiteRiskOn = false;		bBlackRiskOn = false;				iKnightCoupBal = 0;		iKnightCoupMovBal = 0;				iPcsInEnemyBlockBal = 0;		iPawnProtPenBal = 0;				iWhiteMvLastProm = 0;		iBlackMvLastProm = 0;				iPromBonWhite = 0; 		iPromBonBlack = 0;				iKingCtrlFixBal = 0;				iSwapBal = 0;		iEGSBal = 0;				bBottom = false;				iCutBranchLevel = CUTBRANCH_INIT;				iQRKillBal = 0;					}		void setBalancesFromBoard (chessboard cb, int iTurn, int iAlg)	{		//System.out.println("DBG150130:ENTER:setBalancesFromBoard:iTurn:" + iTurn + " alg:" + iAlg);				//iValSumWhite = cb.pvaluesum(piece.WHITE);		//iValSumBlack = cb.pvaluesum(piece.BLACK);				iValSumWhite = cb.iValSumWhite;		iValSumBlack = cb.iValSumBlack;				//iPieceBalance = cb.pvaluesum(piece.WHITE) - cb.pvaluesum(piece.BLACK);				iPieceBalance = iValSumWhite - iValSumBlack;				iCoverageBalance = cb.iWhiteCovered - cb.iBlackCovered;		iPawnAdvBalance = cb.iWhitePawnAdvance - cb.iBlackPawnAdvance;				iProtThreatDiff = cb.iWhiteUnprotThreat - cb.iBlackUnprotThreat;				iLODevDiff = cb.iUndevelopedLightOfficers(Piece.BLACK) - cb.iUndevelopedLightOfficers(Piece.WHITE);				if ((iAlg < ALG_CASTLE_BY_KIC) || (iAlg > ALG_CASTLE_BY_KIC_PLUS))		{			if ((iAlg >= ALG_CASTLE_BY_FLAG) && (iAlg <= ALG_CASTLE_BY_FLAG_PLUS))			{				//System.out.println("DBG(2):alg:" + iAlg);				if (cb.bWhiteCastled)					if (cb.bBlackCastled) iCastledDiff = 0;					else iCastledDiff = 1;				else					if (cb.bBlackCastled) iCastledDiff = -1;					else iCastledDiff = 0;									if (iAlg == ALG_CASTLE_BY_FLAG) iCastledDiff = 2 * iCastledDiff;				if (iAlg == ALG_CASTLE_BY_FLAG_MED) iCastledDiff = 5 * iCastledDiff;				if (iAlg == ALG_CASTLE_BY_FLAG_PLUS) iCastledDiff = 8 * iCastledDiff;							}			else			{				if (cb.bKingInCastle(Piece.WHITE))					if (cb.bKingInCastle(Piece.BLACK)) iCastledDiff = 0;					else iCastledDiff = 3;				else					if (cb.bKingInCastle(Piece.BLACK)) iCastledDiff = -3;					else iCastledDiff = 0;			}			}		 		else		{			switch (iAlg)			{				case ALG_CASTLE_BY_KIC:					iCastledDiff = cb.iKicPoints(Piece.WHITE) - cb.iKicPoints(Piece.BLACK);					break;								case ALG_CASTLE_BY_KIC_LITE:					iCastledDiff = Math.max(cb.iKicPoints(Piece.WHITE)-2,0) - Math.max(cb.iKicPoints(Piece.BLACK)-2,0);					break;									case ALG_CASTLE_BY_KIC_PLUS:				    int kpw = cb.iKicPoints(Piece.WHITE);					int kpb = cb.iKicPoints(Piece.BLACK);					//System.out.println("DBG: KICPOINTS : w: " + kpw + " b: " + kpb);					if (kpw > 0) kpw = kpw+2;					if (kpb > 0) kpb = kpb+2;					iCastledDiff = kpw-kpb;					break;								default:					System.out.println("Mixup in movevalue.setBalancesFromBoard()");					throw new RuntimeException("Mixup in movevalue.setBalancesFromBoard()");			}		}				//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE A");				iDoublePawnDiff = cb.iBlackDoublePawns - cb.iWhiteDoublePawns;		iCenterControlDiff = cb.iWhiteCenterCtrlPts - cb.iBlackCenterCtrlPts ;				bWhiteChecked = cb.bWhiteKingThreat;		bBlackChecked = cb.bBlackKingThreat;						bWhiteBlocked = cb.bWhiteBlocked;		bBlackBlocked = cb.bBlackBlocked;				iMaxWhiteThreat = cb.iMaxWhiteThreat;		iMaxBlackThreat = cb.iMaxBlackThreat;				/*if (bWhiteChecked && bWhiteBlocked) bWhiteCheckMate = true;		else bWhiteCheckMate = false;		if (bBlackChecked && bBlackBlocked) bBlackCheckMate = true;		else bBlackCheckMate = false;		*/        bWhiteCheckMate = bWhiteChecked && (cb.iWhiteMoves == 0);        bBlackCheckMate = bBlackChecked && (cb.iBlackMoves == 0);				//System.out.println("DBG:150123:bWhiteChecked: " + bWhiteChecked + ", bWhiteCheckmate = " + bWhiteCheckMate );						iMaxWhiteThrProtBal =  cb.iMaxWhiteThrProtBal;		iMaxBlackThrProtBal = cb.iMaxBlackThrProtBal;				iKingCtrlDiff = cb.iWhiteKingCtrlBlks - cb.iBlackKingCtrlBlks;				iEGPenDiff = cb.iBlackEarlyGamePenalty - cb.iWhiteEarlyGamePenalty;		iKingSpaceDiff = cb.iWhiteKingSpace - cb.iBlackKingSpace;				iFreePawnPointBal = cb.iWhiteFreePawnPoints - cb.iBlackFreePawnPoints;				// 140510 		bEndGameMode = cb.bInEndGameMode();		bKillModeQRwK = cb.bKillModeQRwK();		bPawnPromRace=  cb.bPawnPromRaceMode();			iKingDistanceBal = cb.kingDistanceBalance();		iKnightCoupBal = Math.max(cb.iWhiteKCS,cb.iWhiteBCS) - Math.max(cb.iBlackKCS, cb.iBlackBCS);		iKnightCoupMovBal = Math.max(cb.iWhiteKCSMoves,cb.iWhiteBCSMoves) - Math.max(cb.iBlackKCSMoves,cb.iBlackBCSMoves);			iInstWinCorr = cb.iInstWinCorr;		//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE B" + iTurn + " IWC :" + iInstWinCorr);				iPcsInEnemyBlockBal = cb.iBlacksInWhiteBlock - cb.iWhitesInBlackBlock;				iPromBonWhite = cb.iPromBonWhite; 		iPromBonBlack = cb.iPromBonBlack;			iKingCtrlFixBal = cb.iWhiteKingCtrlFix - cb.iBlackKingCtrlFix;			if (iTurn == Piece.BLACK)		{			//iPieceBalCorrWhite = iPieceBalance - Math.min(iMaxWhiteThrProtBal/3,1) + iKnightCoupBal;			//iPieceBalCorrWhite = iPieceBalance - (int)(iMaxWhiteThrProtBal/1.5) + iKnightCoupBal;			//iPieceBalCorrWhite = iPieceBalance - (int)(iMaxWhiteThrProtBal/1.2) + iKnightCoupBal;			//if (iKnightCoupMovBal < 0) iPieceBalCorrWhite = iPieceBalCorrWhite - 2;						int iFix = 0;			int iThr = 0;						//if (iAlg != ALG_NEW_ZEROBALANCE) iThr = (int)(iMaxWhiteThrProtBal/1.2);						if (!((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST))) iThr = (int)(iMaxWhiteThrProtBal/1.2);			else iThr = cb.iBlackZeroBal;						//System.out.println("DBG150318:cb.iBlackZeroBal:" + cb.iBlackZeroBal);						// Math.abs added to iThr 150827			//if (Math.abs(iThr) > Math.abs(iKnightCoupBal)  ) iFix = iThr;			if (Math.abs(iThr) > Math.abs(iKnightCoupBal) && (Math.abs(iThr) < 100) ) iFix = iThr;			else iFix = -iKnightCoupBal;						if ((iKnightCoupMovBal < 0) && (Math.abs(iKnightCoupMovBal) > Math.abs(iFix))) iFix = -iKnightCoupMovBal;						if (Math.abs(iInstWinCorr) > Math.abs(iFix)) iPieceBalCorrWhite = iPieceBalance + iInstWinCorr;			else iPieceBalCorrWhite =iPieceBalance - iFix;						//iPieceBalCorrWhite = iPieceBalance + iKnightCoupBal;			iPieceBalCorrBlack = iPieceBalance + iKnightCoupBal + iInstWinCorr;						//System.out.println("DBG151012: iPromBonBlack:" + iPromBonBlack);						if (Math.abs(iPromBonBlack) >= Math.abs(iPieceBalCorrWhite-iPieceBalance)) iPieceBalCorrWhite = iPieceBalance+iPromBonBlack;						//System.out.println("DBG150129 (PB): iTurn:" + iTurn + " iFix:" + iFix + " KCB:" + iKnightCoupBal + " KCMB:"+ iKnightCoupMovBal +  " iInstWinCorr:" +iInstWinCorr+ " iPieceBalCorrWhite:" + iPieceBalCorrWhite + " iPieceBalCorrBlack:"+ iPieceBalCorrBlack);		}		else  // piece.WHITE starts here		{			//iPieceBalCorrBlack = iPieceBalance + Math.min(iMaxBlackThrProtBal/3,1) + iKnightCoupBal;			//iPieceBalCorrBlack = iPieceBalance + (int)(iMaxBlackThrProtBal/1.5) + iKnightCoupBal;						//iPieceBalCorrBlack = iPieceBalance + (int)(iMaxBlackThrProtBal/1.2) + iKnightCoupBal;			//if (iKnightCoupMovBal > 0)  iPieceBalCorrBlack = iPieceBalCorrBlack + 2;						//System.out.println("DBG150130 (PW): iTurn:" + iTurn + " iMaxBlackThrProtBal:" + iMaxBlackThrProtBal);						int iFix = 0;			int iThr = 0;						// $$$ NEW 150223			//if (iAlg != ALG_NEW_ZEROBALANCE) iThr = (int)(iMaxBlackThrProtBal/1.2);						if (!((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST))) iThr = (int)(iMaxBlackThrProtBal/1.2); 			else iThr = cb.iWhiteZeroBal;						// Math.abs added to iThr 150827			//if (Math.abs(iThr) > Math.abs(iKnightCoupBal) ) iFix = iThr;			if (Math.abs(iThr) > Math.abs(iKnightCoupBal) && (Math.abs(iThr) < 100) ) iFix = iThr;			else iFix = iKnightCoupBal;						if ((iKnightCoupMovBal > 0) && (Math.abs(iKnightCoupMovBal) > Math.abs(iFix))) iFix = iKnightCoupMovBal;						if (Math.abs(iInstWinCorr) > Math.abs(iFix)) iPieceBalCorrBlack = iPieceBalance + iInstWinCorr;			else iPieceBalCorrBlack =iPieceBalance + iFix;						//iPieceBalCorrBlack = iPieceBalance + iKnightCoupBal;			iPieceBalCorrWhite = iPieceBalance + iKnightCoupBal + iInstWinCorr ;			//System.out.println("DBG151012: iPromBonWhite:" + iPromBonWhite);			if (Math.abs(iPromBonWhite) >= Math.abs(iPieceBalCorrBlack-iPieceBalance)) iPieceBalCorrBlack = iPieceBalance+iPromBonWhite;							//System.out.println("DBG150129 (PW): iTurn:" + iTurn + " iFix:" + iFix + " KCB:" + iKnightCoupBal + " KCMB:"+ iKnightCoupMovBal +  " iInstWinCorr:" +iInstWinCorr+" iPieceBalCorrWhite:" + iPieceBalCorrWhite + " iPieceBalCorrBlack:"+ iPieceBalCorrBlack + " cb.whitezerobal:" + cb.iWhiteZeroBal + " iPieceBalance:" + iPieceBalance);		}				//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE C: corrs: "+iPieceBalCorrWhite+","+iPieceBalCorrBlack);				iFreePawnCtrlBal = cb.iWhiteFreePawnCtrlPoints - cb.iBlackFreePawnCtrlPoints;				iMoveCount = cb.iMoveCount;				iWhiteCastlingMove = cb.iWhiteCastlingMove;		iBlackCastlingMove = cb.iBlackCastlingMove;				iCheckMoveBal = cb.iWhiteCheckMoves - cb.iBlackCheckMoves;				//iMoveListLenghtBal = cb.iWhiteMoves - cb.iBlackMoves;		iMoveListLenghtBal = (int)((cb.iWhiteMoves - cb.iBlackMoves) * 0.5);				//System.out.println("DBG:150123: white moves: " + cb.iWhiteMoves);				iQESBal = cb.iWhiteQES - cb.iBlackQES;				//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE CC");				bWhiteInstWin = cb.bWhiteInstWin;		bBlackInstWin = cb.bBlackInstWin;						//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE DD");				bWhiteRiskOn = cb.bWhiteRiskOn;		bBlackRiskOn = cb.bBlackRiskOn;				//System.out.println("DBG(1):ENTER:setBalancesFromBoard: PLACE D");						bBottom = false;				iPawnProtPenBal = cb.iPawnProtPenBal;				iWhiteMvLastProm = cb.iWhiteMvLastProm;		iBlackMvLastProm = cb.iBlackMvLastProm;				iSwapBal = cb.iSwapBalance;		iEGSBal = cb.iEGSBal;				iQRKillBal = cb.iQRKillBal;				//System.out.println("DBG(1):LEAVE:setBalancesFromBoard:alg:" + iAlg + " pieceballcorrwhite " + iPieceBalCorrWhite);	}		void setbase(int iColor)	{		//System.out.print("setbase():");				if (iColor == 0) 		{			bWhiteCheckMate = true;			bBlackCheckMate = false;		}		else 		{				bBlackCheckMate = true;			bWhiteCheckMate = false;		}				//bBottom = true;    // 140320 trial, may not be needed .....		//System.out.println(dumpstr());	}		movevalue copy ()	{		movevalue mv2;				mv2 = new movevalue(sSeq,iPieceBalance,iCoverageBalance,iPawnAdvBalance,iProtThreatDiff,iCastledDiff,iLODevDiff,iDoublePawnDiff,			iCenterControlDiff,bWhiteCheckMate,bWhiteChecked,bWhiteBlocked,bBlackCheckMate,bBlackChecked,bBlackBlocked,iMaxWhiteThreat,			iMaxBlackThreat,iMaxWhiteThrProtBal,iMaxBlackThrProtBal,iKingCtrlDiff, iEGPenDiff, iKingSpaceDiff, iFreePawnPointBal, 			bEndGameMode,  bKillModeQRwK,  bPawnPromRace,  iKingDistanceBal, iPieceBalCorrWhite, iPieceBalCorrBlack, iValSumWhite, 			iValSumBlack, iMoveCount, iFreePawnCtrlBal, iWhiteCastlingMove,			iBlackCastlingMove, iCheckMoveBal, iMoveListLenghtBal, iQESBal, iKnightCoupBal,iKnightCoupMovBal,bWhiteInstWin, bBlackInstWin, iInstWinCorr,bWhiteRiskOn, bBlackRiskOn,  iPcsInEnemyBlockBal, iPawnProtPenBal, iWhiteMvLastProm, iBlackMvLastProm, iPromBonWhite, iPromBonBlack, iKingCtrlFixBal , iSwapBal, iEGSBal, iCutBranchLevel, iQRKillBal  );        mv2.bBottom = bBottom;				mv2.sRoute = sRoute;		mv2.sMessage = sMessage;				return mv2;	}		void copyfrom (movevalue mv)	{		sSeq = mv.sSeq;		sRoute = mv.sRoute;			iPieceBalance = mv.iPieceBalance;		iCoverageBalance = mv.iCoverageBalance;		iPawnAdvBalance = mv.iPawnAdvBalance;				iProtThreatDiff = mv.iProtThreatDiff;		iCastledDiff = mv.iCastledDiff;		iLODevDiff = mv.iLODevDiff;			iDoublePawnDiff = mv.iDoublePawnDiff;		iCenterControlDiff = mv.iCenterControlDiff;						bWhiteCheckMate = mv.bWhiteCheckMate;		bWhiteChecked = mv.bWhiteChecked;		bWhiteBlocked = mv.bWhiteBlocked;				bBlackCheckMate = mv.bBlackCheckMate;		bBlackChecked = mv.bBlackChecked;		bBlackBlocked = mv.bBlackBlocked;				iMaxWhiteThreat = mv.iMaxWhiteThreat;		iMaxBlackThreat = mv.iMaxBlackThreat;				iMaxWhiteThrProtBal =  mv.iMaxWhiteThrProtBal;		iMaxBlackThrProtBal = mv.iMaxBlackThrProtBal;				iKingCtrlDiff = mv.iKingCtrlDiff;				iEGPenDiff =  mv.iEGPenDiff;		iKingSpaceDiff = mv.iKingSpaceDiff;			iFreePawnPointBal = mv.iFreePawnPointBal;				bEndGameMode = mv.bEndGameMode;		bKillModeQRwK = mv.bKillModeQRwK;		bPawnPromRace= mv.bPawnPromRace;			iKingDistanceBal = mv.iKingDistanceBal;				iPieceBalCorrWhite = mv.iPieceBalCorrWhite;		iPieceBalCorrBlack = mv.iPieceBalCorrBlack;			iValSumWhite = mv.iValSumWhite;		iValSumBlack = mv.iValSumBlack;				iFreePawnCtrlBal = mv.iFreePawnCtrlBal;				iMoveCount = mv.iMoveCount;				iWhiteCastlingMove = mv.iWhiteCastlingMove;		iBlackCastlingMove = mv.iBlackCastlingMove;			iCheckMoveBal = mv.iCheckMoveBal;				iMoveListLenghtBal = mv.iMoveListLenghtBal;		iQESBal = mv.iQESBal;			bWhiteInstWin = mv.bWhiteInstWin;		bBlackInstWin = mv.bBlackInstWin;				iInstWinCorr = mv.iInstWinCorr;			bWhiteRiskOn = mv.bWhiteRiskOn;		bBlackRiskOn = mv.bBlackRiskOn;			iKnightCoupBal = mv.iKnightCoupBal;		iKnightCoupMovBal = mv.iKnightCoupMovBal;				iPcsInEnemyBlockBal = mv.iKnightCoupMovBal;		iPawnProtPenBal = mv.iPawnProtPenBal;				iWhiteMvLastProm = mv.iWhiteMvLastProm;		iBlackMvLastProm = mv.iBlackMvLastProm;				iPromBonWhite = mv.iPromBonWhite;		iPromBonBlack = mv.iPromBonBlack;				iKingCtrlFixBal = mv.iKingCtrlFixBal;				iSwapBal = mv.iSwapBal;		iEGSBal = mv.iEGSBal;				bBottom = mv.bBottom;				iCutBranchLevel = mv.iCutBranchLevel;				iQRKillBal = mv.iQRKillBal;				sMessage = mv.sMessage;	}		void replaceValues(int xk1, int yk1, int xk2, int yk2, int ipB, int icB, int ipaB, int iptB, int icasB, int ilodB, int idpB, 		int iccB, boolean bWcm, boolean bWc, boolean bWb, boolean bBcm, boolean bBc, boolean bBb, int iMWT, int iMBT, int iMWTB, 		int iMBTB, int ikcb, int iegPB, int ikSB, int ifppB, boolean bEGM, boolean bKMQ, boolean bPPR, int ikdb, int ipbcw, 		int ipbcb, int ivsw, int ivsb, int iMc, int ifpcb, int iwcm, int ibcm, int icmoB, int imllb, int iqesB, int iKCB, int iKCMB,boolean bWiW, boolean bBiW, int iIWC, boolean bWRO, boolean bBRO, int iPIEB, int iPPPB, int iWMLP, int iBMLP, int iPBW, int iPBB, int iKCFB, int iSwB, int iEGSB, int iCBL, int iQRKB)	{		sSeq = "" + (char)(xk1+64) + yk1 + (char)(xk2+64) + yk2;				iPieceBalance = ipB;		iCoverageBalance = icB;		iPawnAdvBalance = ipaB;				iProtThreatDiff = iptB;		iCastledDiff = icasB;		iLODevDiff = ilodB;			iDoublePawnDiff = idpB;		iCenterControlDiff = iccB;				bWhiteCheckMate = bWcm;		bWhiteChecked = bWc;		bWhiteBlocked = bWb;				bBlackCheckMate = bBcm;		bBlackChecked = bBc;		bBlackBlocked = bBb;		iMaxWhiteThreat = iMWT;		iMaxBlackThreat = iMBT; 				iMaxWhiteThrProtBal = iMWTB;		iMaxBlackThrProtBal = iMBTB;				iEGPenDiff = iegPB;		iKingSpaceDiff = ikSB;				iKingCtrlDiff = ikcb;				iFreePawnPointBal = ifppB;				bEndGameMode = bEGM;		bKillModeQRwK = bKMQ;		bPawnPromRace= bPPR;			iKingDistanceBal = ikdb;				iPieceBalCorrWhite = ipbcw;		iPieceBalCorrBlack = ipbcb;			iValSumWhite = ivsw;		iValSumBlack = ivsb;				iFreePawnCtrlBal = ifpcb;				iWhiteCastlingMove = iwcm;		iBlackCastlingMove = ibcm;				iCheckMoveBal = icmoB;				iMoveListLenghtBal = imllb;		iQESBal = iqesB;				bWhiteInstWin = bWiW;		bBlackInstWin = bBiW;				iInstWinCorr = iIWC;				bWhiteRiskOn = bWRO;		bBlackRiskOn = bBRO;				iKnightCoupBal = iKCB;		iKnightCoupMovBal = iKCMB;				iKnightCoupMovBal = iPIEB;		iPawnProtPenBal = iPPPB;				iWhiteMvLastProm = iWMLP;		iBlackMvLastProm = iBMLP;				iPromBonWhite = iPBW; 		iPromBonBlack = iPBB;				iKingCtrlFixBal = iKCFB;				iSwapBal = iSwB;		iEGSBal = iEGSB;		iMoveCount = iMc;				iCutBranchLevel = iCBL;	}		/*	boolean isBetterthan (movevalue mv2, int iColor, int iAlg, int iTurn)	{		String s = "";		return isBetterthanXX(mv2,iColor,iAlg,iTurn,s);	}	*/	boolean isBetterthan (movevalue mv2, int iColor, int iAlg, int iTurn, int iRounds)	//boolean isBetterthan (movevalue mv2, int iColor, int iAlg, int iTurn)	{		return isBetterthan(mv2,iColor,iAlg,iTurn,iRounds,true);	}		boolean isBetterthan (movevalue mv2, int iColor, int iAlg, int iTurn, int iRounds, boolean bLookAtCuts)	//boolean isBetterthan (movevalue mv2, int iColor, int iAlg, int iTurn)	{		CMonitor.incValueComp();		/*		System.out.println("DBG150129:IBT called!  col:" + iColor + " Turn: " + iTurn + " Alrgorithm: " + iAlg);		System.out.println("DBG150129: IBT: own " + dumpstr(iAlg,DUMPMODE_SHORT) + " PBCW: " + iPieceBalCorrWhite);		System.out.println("DBG150129: IBT: other " + mv2.dumpstr(iAlg,DUMPMODE_SHORT) + " PBCW: " + iPieceBalCorrWhite);		*/				//sDBG = "X:";				if (bBottom) return false;		if (mv2.bBottom) return true;				if (bLookAtCuts)		{			boolean bOwnCutter = ((iCutBranchLevel >= 0) && (iRounds < iCutBranchLevel+2));			boolean bOtherCutter = ((mv2.iCutBranchLevel >= 0) && (iRounds < mv2.iCutBranchLevel+2));			{				if (bOwnCutter && !bOtherCutter) return false;				if (!bOwnCutter && bOtherCutter) return true;			}		}						int iBalFix = 0;		int iThrDiff = 0;		int iThrCorr = 0;		iThrCorr = thrCorr(iAlg, iTurn, mv2);		resetLastProms(mv2);				//System.out.println("DBG:ibt:iThrCorr=" + iThrCorr);				if (iColor == Piece.WHITE)		{			sDBG = sDBG + "w1";						if (bBlackCheckMate && mv2.bBlackCheckMate)			{				if (iMoveCount < mv2.iMoveCount) return true;				if (iMoveCount > mv2.iMoveCount) return false;			}						if (bWhiteCheckMate && mv2.bWhiteCheckMate)			{				if (iMoveCount > mv2.iMoveCount) return true;				if (iMoveCount < mv2.iMoveCount) return false;			}						if (bBlackCheckMate) return true;			if (mv2.bBlackCheckMate) return false;						if (bWhiteCheckMate) return false;			if (mv2.bWhiteCheckMate) return true;						if ((bWhiteInstWin) && (!mv2.bWhiteInstWin)) return false;			if ((mv2.bWhiteInstWin) && (!bWhiteInstWin)) return true;						if ((bBlackInstWin) && (!mv2.bBlackInstWin)) return true;			if ((mv2.bBlackInstWin) && (!bBlackInstWin)) return false;						/*			if (iTurn == piece.BLACK)			{				if ((bWhiteRiskOn) && (!mv2.bWhiteRiskOn))  return false;				if ((mv2.bWhiteRiskOn) && (!bWhiteRiskOn) ) return true;			}			*/						sDBG = sDBG + "w2";						if ((iQRKillBal > 0) && (mv2.iQRKillBal <= 0)) return true;			if ((iQRKillBal < 0) && (mv2.iQRKillBal >= 0)) return false;			if ((iQRKillBal >= 0) && (mv2.iQRKillBal < 0)) return true;			if ((iQRKillBal <= 0) && (mv2.iQRKillBal > 0)) return false;						if (((iAlg == ALG_NEWAVOIDTHREAT_BAL) || (iAlg == ALG_NEWAVOIDTHREAT_BAL_COMBO) ||				(iAlg == ALG_DEEP_CHECK ) || 			    (iAlg == ALG_DEFAULT) || (iAlg == ALG_CHECKMOVE_BAL) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1) || (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_QUEEN_ESCAPE) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || ((iAlg >= ALG_CASTLE_BY_KIC) && (iAlg <= ALG_CASTLE_BY_FLAG_PLUS))) && 			    (iTurn == Piece.BLACK))			{				if ( iPieceBalCorrWhite > mv2.iPieceBalCorrWhite) return true;				if (iPieceBalCorrWhite < mv2.iPieceBalCorrWhite) return false;				sDBG = sDBG + "w3";			}												if (((iAlg == ALG_NEWAVOIDTHREAT_BAL) || (iAlg == ALG_NEWAVOIDTHREAT_BAL_COMBO) || 			    (iAlg == ALG_DEFAULT) || (iAlg == ALG_DEEP_CHECK ) ||(iAlg == ALG_CHECKMOVE_BAL) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1)|| (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_QUEEN_ESCAPE) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || ((iAlg >= ALG_CASTLE_BY_KIC) && (iAlg <= ALG_CASTLE_BY_FLAG_PLUS)))  && (iTurn == Piece.WHITE))			{				if (iPieceBalCorrBlack > mv2.iPieceBalCorrBlack) return true;				if (iPieceBalCorrBlack < mv2.iPieceBalCorrBlack) return false;								sDBG = sDBG + "w3x";			}						if ((iWhiteMvLastProm != mv2.iWhiteMvLastProm)) 			{	 				if ( (iWhiteMvLastProm != 0) && (mv2.iWhiteMvLastProm != 0))				{					//System.out.println("DGB 150426: DIFF in Last Proms!! Impact decision!!!");					//if (iWhiteMvLastProm == 0) return false;					//if (mv2.iWhiteMvLastProm == 0) return true;                    return iWhiteMvLastProm < mv2.iWhiteMvLastProm;				}				if (iWhiteMvLastProm == 0) return false;				if (mv2.iWhiteMvLastProm == 0) return true;			}						sDBG = sDBG + "w3y";						if ((iBlackMvLastProm != mv2.iBlackMvLastProm)) 			{				if ((iBlackMvLastProm != 0) && (mv2.iBlackMvLastProm != 0)) 				{					//System.out.println("DGB 150426: DIFF in Last Proms!! Impact decision!!!");					//if (iBlackMvLastProm == 0) return false;					//if (mv2.iBlackMvLastProm == 0) return true;                    return iBlackMvLastProm >= mv2.iBlackMvLastProm;				}				if (iBlackMvLastProm == 0) return true;				if (mv2.iBlackMvLastProm == 0) return false;			}						sDBG = sDBG + "w3z";													// thrcorr replaced ages ago, isn't it?? 140602			//if (iPieceBalance - iThrCorr > mv2.iPieceBalance) return true;			//if (iPieceBalance - iThrCorr < mv2.iPieceBalance) return false;						sDBG = sDBG + "w4";						if (iPieceBalance  > mv2.iPieceBalance) return true;			if (iPieceBalance  < mv2.iPieceBalance) return false;						// 140320 issue trial			//if (iPieceBalance + iBalFix > mv2.iPieceBalance) return true;			//if (iPieceBalance + iBalFix < mv2.iPieceBalance) return false;						sDBG = sDBG + "w4b";						if (bBlackChecked && !mv2.bBlackChecked) return true;			if (!bBlackChecked && mv2.bBlackChecked) return false;						// 140429 check condition both ways experiment			if (iAlg != ALG_CHECKONEWAYONLY)			{				if (bWhiteChecked && !mv2.bWhiteChecked) return false;				if (!bWhiteChecked && mv2.bWhiteChecked) return true;			}						//if (iCoverageBalance > mv2.iCoverageBalance) return true;			//if (iCoverageBalance < mv2.iCoverageBalance) return false;						sDBG = sDBG + "w5";						if (iCalcValue(iAlg,iTurn) > mv2.iCalcValue(iAlg,iTurn))return true;			if (iCalcValue(iAlg,iTurn) < mv2.iCalcValue(iAlg,iTurn))return false;					if ((iWhiteCastlingMove != 0) && (mv2.iWhiteCastlingMove != 0) && 				(iWhiteCastlingMove < mv2.iWhiteCastlingMove)) return true;			if ((iWhiteCastlingMove != 0) && (mv2.iWhiteCastlingMove != 0) && 				(iWhiteCastlingMove > mv2.iWhiteCastlingMove)) return false;					if (iTurn == Piece.WHITE)			{				if (bWhiteBlocked && !mv2.bWhiteBlocked) return true;				if (!bWhiteBlocked && mv2.bWhiteBlocked) return false;				if (bBlackBlocked && !mv2.bBlackBlocked) return false;				if (!bBlackBlocked && mv2.bBlackBlocked) return true;			}			else			{				if (bWhiteBlocked && !mv2.bWhiteBlocked) return false;				if (!bWhiteBlocked && mv2.bWhiteBlocked) return true;				if (bBlackBlocked && !mv2.bBlackBlocked) return true;                return bBlackBlocked || !mv2.bBlackBlocked;			}						return true;		}		else  // iColor == piece.BLACK from here on		{			//System.out.println("DBG150130: IBT iC Black (A)");						if (bWhiteCheckMate && mv2.bWhiteCheckMate)			{				if (iMoveCount < mv2.iMoveCount) return true;				if (iMoveCount > mv2.iMoveCount) return false;			}						if (bBlackCheckMate && mv2.bBlackCheckMate)			{				if (iMoveCount > mv2.iMoveCount) return true;				if (iMoveCount < mv2.iMoveCount) return false;			}						if (bWhiteCheckMate) return true;			if (mv2.bWhiteCheckMate) return false;						if (mv2.bBlackCheckMate) return true;			if (bBlackCheckMate) return false;						if ((bBlackInstWin) && (!mv2.bBlackInstWin)) return false;			if ((mv2.bBlackInstWin) && (!bBlackInstWin)) return true;						if ((bWhiteInstWin) && (!mv2.bWhiteInstWin)) return true;			if ((mv2.bWhiteInstWin) && (!bWhiteInstWin)) return false;						/*if (iTurn == piece.WHITE)			{							if ((bBlackRiskOn) && (!mv2.bBlackRiskOn)) return false;				if ((mv2.bBlackRiskOn) && (!bBlackRiskOn)) return true;			}*/						//System.out.println("DBG150130: IBT iC Black (B)");						if ((iQRKillBal > 0) && (mv2.iQRKillBal <= 0)) return false;			if ((iQRKillBal < 0) && (mv2.iQRKillBal >= 0)) return true;			if ((iQRKillBal >= 0) && (mv2.iQRKillBal < 0)) return false;			if ((iQRKillBal <= 0) && (mv2.iQRKillBal > 0)) return true;						//System.out.println("DBG150130: IBT iC Black (B2)");						if (((iAlg == ALG_NEWAVOIDTHREAT_BAL) || (iAlg == ALG_NEWAVOIDTHREAT_BAL_COMBO) ||                (iAlg == ALG_DEEP_CHECK ) ||						    (iAlg == ALG_DEFAULT) || (iAlg == ALG_CHECKMOVE_BAL) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1)|| (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_QUEEN_ESCAPE) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || ((iAlg >= ALG_CASTLE_BY_KIC) && (iAlg <= ALG_CASTLE_BY_FLAG_PLUS))) && 			    (iTurn == Piece.WHITE))			{				//System.out.println("DBG150130: IBT iC Black (C0): own" + iPieceBalCorrBlack + " mv2: " + mv2.iPieceBalCorrBlack);				if ( iPieceBalCorrBlack < mv2.iPieceBalCorrBlack) return true;				if (iPieceBalCorrBlack > mv2.iPieceBalCorrBlack) return false;											}			sDBG = sDBG + "b2";						if (((iAlg == ALG_NEWAVOIDTHREAT_BAL) || (iAlg == ALG_NEWAVOIDTHREAT_BAL_COMBO) || 			    (iAlg == ALG_DEFAULT) || (iAlg == ALG_DEEP_CHECK ) || (iAlg == ALG_CHECKMOVE_BAL) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1)|| (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_QUEEN_ESCAPE) || (iAlg == ALG_KNIGHT_COUP)  || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || ((iAlg >= ALG_CASTLE_BY_KIC) && (iAlg <= ALG_CASTLE_BY_FLAG_PLUS))) && (iTurn == Piece.BLACK))			{				//System.out.println("DBG150130: IBT iC Black (D0)");				if (iPieceBalCorrWhite < mv2.iPieceBalCorrWhite) return true;				if (iPieceBalCorrWhite > mv2.iPieceBalCorrWhite) return false;								sDBG = sDBG + "b3x";			}							if ((iBlackMvLastProm != mv2.iBlackMvLastProm)) 			{				if ((iBlackMvLastProm != 0) && (mv2.iBlackMvLastProm != 0)) 				{					//System.out.println("DGB 150426: DIFF in Last Proms!! Impact decision!!!");					//if (iBlackMvLastProm == 0) return false;					//if (mv2.iBlackMvLastProm == 0) return true;                    return iBlackMvLastProm < mv2.iBlackMvLastProm;				}				if (iBlackMvLastProm == 0) return false;				if (mv2.iBlackMvLastProm == 0) return true;			}						sDBG = sDBG + "b3x2";						if ((iWhiteMvLastProm != mv2.iWhiteMvLastProm)) 			{	 				if ( (iWhiteMvLastProm != 0) && (mv2.iWhiteMvLastProm != 0))				{					//System.out.println("DGB 150426: DIFF in Last Proms!! Impact decision!!!");					//if (iWhiteMvLastProm == 0) return false;					//if (mv2.iWhiteMvLastProm == 0) return true;                    return iWhiteMvLastProm >= mv2.iWhiteMvLastProm;				}				if (iWhiteMvLastProm == 0) return true;				if (mv2.iWhiteMvLastProm == 0) return false;			}						sDBG = sDBG + "b3x3";													//System.out.println("DBG150130: IBT iC Black (D)");						// thrcorr replaced ages ago, isn't it?? 140602			//if (iPieceBalance + iThrCorr < mv2.iPieceBalance) return true;			//if (iPieceBalance + iThrCorr > mv2.iPieceBalance) return false;						if (iPieceBalance  < mv2.iPieceBalance) return true;			if (iPieceBalance  > mv2.iPieceBalance) return false;						// 140320 issue trial			//if (iPieceBalance - iBalFix < mv2.iPieceBalance) return true;			//if (iPieceBalance - iBalFix > mv2.iPieceBalance) return false;						if (bWhiteChecked && !mv2.bWhiteChecked) return true;			if (!bWhiteChecked && mv2.bWhiteChecked) return false;						// 140429 check condition both ways experiment			if (iAlg != ALG_CHECKONEWAYONLY)			{				if (bBlackChecked && !mv2.bBlackChecked) return false;				if (!bBlackChecked && mv2.bBlackChecked) return true;			}									//if (iCoverageBalance < mv2.iCoverageBalance) return true;			//if (iCoverageBalance > mv2.iCoverageBalance) return false;							if (iCalcValue(iAlg,iTurn) < mv2.iCalcValue(iAlg,iTurn))return true;			if (iCalcValue(iAlg,iTurn) > mv2.iCalcValue(iAlg,iTurn))return false;					if ((iBlackCastlingMove != 0) && (mv2.iBlackCastlingMove != 0) && 				(iBlackCastlingMove < mv2.iBlackCastlingMove)) return true;			if ((iBlackCastlingMove != 0) && (mv2.iBlackCastlingMove != 0) && 				(iBlackCastlingMove > mv2.iBlackCastlingMove)) return false;						if (iTurn == Piece.WHITE)			{				if (bWhiteBlocked && !mv2.bWhiteBlocked) return true;				if (!bWhiteBlocked && mv2.bWhiteBlocked) return false;				if (bBlackBlocked && !mv2.bBlackBlocked) return false;				if (!bBlackBlocked && mv2.bBlackBlocked) return true;			}			else			{				if (bWhiteBlocked && !mv2.bWhiteBlocked) return false;				if (!bWhiteBlocked && mv2.bWhiteBlocked) return true;				if (bBlackBlocked && !mv2.bBlackBlocked) return true;                return bBlackBlocked || !mv2.bBlackBlocked;			}						return true;		}	}		boolean equalBalance(int iAlg, int iTurn, movevalue mv2)	{		/*		int iThrCorr = thrCorr(iAlg, iTurn, mv2);				if (iTurn == piece.WHITE)		{			if (iPieceBalance-iThrCorr == mv2.iPieceBalance) return true;			else return false;		}		else		{			if (iPieceBalance+iThrCorr == mv2.iPieceBalance) return true;			else return false;		}		*/		if (iTurn == Piece.WHITE)		{            return iPieceBalCorrBlack == mv2.iPieceBalCorrBlack;		}		else		{            return iPieceBalCorrWhite == mv2.iPieceBalCorrWhite;		}			}		void pushNewSeq (int xk1, int yk1, int xk2, int yk2, int iPromTo)	{		sSeq = "" + (char)(xk1+64) + yk1 + (char)(xk2+64) + yk2;		if (iPromTo != -1)		{			switch (iPromTo)			{				case Piece.QUEEN:					sSeq = sSeq + "Q";					break;									case Piece.ROOK:					sSeq = sSeq + "R";					break;									case Piece.BISHOP:					sSeq = sSeq + "B";					break;									case Piece.KNIGHT:					sSeq = sSeq + "N";					break;									default: 					break;								}		}		pushSeq();	}		void pushSeq()	{		sRoute = sRoute + ";" + sSeq;		if (sRoute.length() > 129) 		{			System.out.println("Too long sRoute!!!" + dumpstr(0));			throw new RuntimeException("Too long sRoute!!!" + dumpstr(0));		}	}		void pushmove(String moveStr)	{		//System.out.println("pushmove:" + moveStr);		sSeq=moveStr;		//System.out.println("pushmove, sSeq:" + sSeq);		pushSeq();	}		void popSeq()	{		sRoute = sRoute.substring(0,sRoute.length()-5);	}		void dump()	{		System.out.println(dumpstr(0));	}		String dumpstr(int iAlg, int dumpmode)	{		String sRet;				if (dumpmode == DUMPMODE_LONG) return dumpstr(iAlg);				sRet = "MOVEVALUE-DUMP: [" +sRoute + "/" + sSeq + "], (" + iPieceBalance + "," + iPieceBalCorrWhite+","+iPieceBalCorrBlack+",) W:(";				if (bWhiteCheckMate) sRet = sRet+"X";		else sRet = sRet+".";		if (bWhiteChecked) sRet = sRet+"X";		else sRet = sRet+".";		if (bWhiteBlocked) sRet = sRet+"X";		else sRet = sRet+".";				sRet = sRet + ") B:(";				if (bBlackCheckMate) sRet = sRet+"X";		else sRet = sRet+".";		if (bBlackChecked) sRet = sRet+"X";		else sRet = sRet+".";		if (bBlackBlocked) sRet = sRet+"X";		else sRet = sRet+".";				sRet = sRet + ") , CV(,(" +	iAlg+")," + iCalcValue(iAlg,0) + "," +iCalcValue(iAlg,1) + ",), iw(";				if (bWhiteInstWin) sRet=sRet+"X";		else sRet=sRet+".";		if (bBlackInstWin) sRet=sRet+"X";		else sRet=sRet+".";				sRet = sRet+","+iInstWinCorr;				sRet = sRet + "), r(";		if (bWhiteRiskOn) sRet=sRet+"X";		else sRet=sRet+".";		if (bBlackRiskOn) sRet=sRet+"X";		else sRet=sRet+".";				sRet = sRet + ")";				if (iCutBranchLevel >= 0) sRet = sRet + " C:"+iCutBranchLevel;				if (sMessage != null) sRet = sRet + sMessage;				return sRet;			}		String dumpstr(int iAlg)	{		String sRet;				sRet = "MOVEVALUE-DUMP: [" +sRoute + "/" + sSeq + "], (" + iPieceBalance + "," + iPieceBalCorrWhite+","+iPieceBalCorrBlack+",) ," +			iCoverageBalance + "," + iPawnAdvBalance + ","+iProtThreatDiff+","+iCastledDiff +"," + iLODevDiff +"," + iDoublePawnDiff+ "," +			iCenterControlDiff + "," + iFreePawnPointBal + ", ZZ: " + iKingSpaceDiff + "," + iKingCtrlDiff + "," + iFreePawnCtrlBal + "," + iWhiteCastlingMove+ ","+ 			iBlackCastlingMove + "," + iCheckMoveBal + "," + iMoveListLenghtBal +  "," +iQESBal + "," + iEGSBal + ", CV(,(" +			iAlg+")," + iCalcValue(iAlg,0) + "," +iCalcValue(iAlg,1) + ",) W:(";				if (bWhiteCheckMate) sRet = sRet+"X";		else sRet = sRet+".";		if (bWhiteChecked) sRet = sRet+"X";		else sRet = sRet+".";		if (bWhiteBlocked) sRet = sRet+"X";		else sRet = sRet+".";				sRet = sRet + ") B:(";				if (bBlackCheckMate) sRet = sRet+"X";		else sRet = sRet+".";		if (bBlackChecked) sRet = sRet+"X";		else sRet = sRet+".";		if (bBlackBlocked) sRet = sRet+"X";		else sRet = sRet+".";				sRet = sRet + ") Maxtr:" + iMaxWhiteThreat + "," + iMaxBlackThreat + " Bal:" + iMaxWhiteThrProtBal +"," + iMaxBlackThrProtBal + "," + iKingDistanceBal + "," +iKnightCoupBal + "," + iKnightCoupMovBal +"," + iPcsInEnemyBlockBal + "," +iPawnProtPenBal + "," +iKingCtrlFixBal +","+iSwapBal+",<"+ iQRKillBal +">  lp:("+ iWhiteMvLastProm + "," + iBlackMvLastProm+ "), pb:(" +iPromBonWhite +"," + iPromBonBlack+") M:(";				if (bEndGameMode) sRet = sRet+"X";		else sRet = sRet+".";		if (bKillModeQRwK) sRet = sRet+"X";		else sRet = sRet+".";		if (bPawnPromRace) sRet = sRet+"X";		else sRet = sRet+".";		sRet = sRet + "), iw(";				if (bWhiteInstWin) sRet=sRet+"X";		else sRet=sRet+".";		if (bBlackInstWin) sRet=sRet+"X";		else sRet=sRet+".";		sRet = sRet+","+iInstWinCorr;				sRet = sRet + "), r(";		if (bWhiteRiskOn) sRet=sRet+"X";		else sRet=sRet+".";		if (bBlackRiskOn) sRet=sRet+"X";		else sRet=sRet+".";				sRet = sRet + "), corr: ( ? ) ";		sRet = sRet + " BOT:" + bBottom + " mc:" + iMoveCount;		 		if (iCutBranchLevel >= 0) sRet = sRet + " C:"+iCutBranchLevel;		if (sMessage != null) sRet = sRet + sMessage;						return sRet; 	}		int iCalcValue(int iAlg, int iTurn)	{		// algcompare.txt explains the pick below:		//System.out.println("iCalcValue alg:" + iAlg);				if (iAlg == ALG_NOKINGCTRBAL) 			return iCoverageBalance + iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance ; 				if (iAlg == ALG_NOLODEVPLUS)			return iCoverageBalance + iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff;				if (iAlg == ALG_EARLYGAMEPEN)			return iCoverageBalance + iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iEGPenDiff*3;				if (iAlg == ALG_KINGSPACER)			return iCoverageBalance + iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingSpaceDiff;				if (iAlg == ALG_NOFREEPAWNBALANCE)			return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff ;					if (iAlg == ALG_CTRCTRL	)			return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + iCenterControlDiff;			// =========================		// special modes		if (((iAlg == ALG_ENDGAMEKILLMODE) || (iAlg == ALG_ENDGAMEDUALMODE) || (iAlg == ALG_DEFAULT) || (iAlg ==ALG_DEEP_CHECK ) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_CHECKMOVE_BAL)) && bKillModeQRwK)    		{			//System.out.println("ALG_ENDGAMEKILLMODE: " + iKingSpaceDiff + "," + iKingDistanceBal);			return iKingSpaceDiff * 5 + iKingDistanceBal +  10 * iKnightCoupMovBal;		}				if (((iAlg == ALG_ENDGAMEMODE) || (iAlg == ALG_ENDGAMEDUALMODE) || (iAlg == ALG_DEFAULT) || (iAlg == ALG_DEEP_CHECK ) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || (iAlg == ALG_MOVELIST_LEN) || (iAlg == ALG_CHECKMOVE_BAL)) && bEndGameMode)			return iProtThreatDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal +  10 * iKnightCoupMovBal + 5 *iKingDistanceBal + iEGSBal;		if (((iAlg == ALG_PAWNPROMRACE) ||			(iAlg == ALG_DEFAULT) || (iAlg == ALG_DEEP_CHECK ) || (iAlg == ALG_CHECKMOVE_BAL) || (iAlg == ALG_NO_OPT_TRAVERSE) || (iAlg == ALG_OPT_TRAV_LEV1) || (iAlg == ALG_KNIGHT_COUP) || ((iAlg >= ALG_NEW_TRAVERSE1) && (iAlg <= ALG_NEW_TRAVERSE_LAST)) || (iAlg == ALG_MOVELIST_LEN) )					&& bPawnPromRace)		{			//System.out.println("DBG160119: bPawnPromRace");						if (iAlg == ALG_MOVELIST_LEN)			return iProtThreatDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 5 *iKingDistanceBal + iMoveListLenghtBal;						return iProtThreatDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 5 *iKingDistanceBal +  10 * iKnightCoupMovBal + iEGSBal;		}				// end special modes 				if (iAlg == ALG_CHECKMOVE_BAL)		{			return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 3 * iCheckMoveBal;		}				if (iAlg == ALG_MOVELIST_LEN) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + iMoveListLenghtBal;				if (iAlg == ALG_QUEEN_ESCAPE) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + iQESBal;				if (iAlg == ALG_PIECES_IN_EB) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal + 10*iPcsInEnemyBlockBal;				if (iAlg == ALG_PPPBAL1) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal +  iPawnProtPenBal;				if (iAlg == ALG_PPPBAL2) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal +  2*iPawnProtPenBal;				if (iAlg == ALG_PPPBAL3) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal +  3*iPawnProtPenBal;				if (iAlg == ALG_SUPER_PRUNING_KINGCFIX) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal + iKingCtrlFixBal;				if (iAlg == ALG_SUPER_PRUNING_SWAPBAL) return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal + + iKingCtrlFixBal + iSwapBal;				return iCoverageBalance + 3 * iLODevDiff + iProtThreatDiff + iCastledDiff + iPawnAdvBalance + iKingCtrlDiff + 2 * iFreePawnPointBal + 10 * iKnightCoupMovBal;				/*		if (iTurn == piece.WHITE) return iCoverageBalance + iLODevDiff + iProtThreatDiff + 3 * iCastledDiff + iPawnAdvBalance + iMaxBlackThreat*2;		else return iCoverageBalance + iLODevDiff + iProtThreatDiff + 3 * iCastledDiff + iPawnAdvBalance - iMaxWhiteThreat*2;		*/								// #1 #2 #3 # 5 + 3*#4 				// black = 223, white = 123		/*		if (iAlg == 0) return iCoverageBalance;		else if (iAlg == 123) return iCoverageBalance + iLODevDiff + iProtThreatDiff;   		else if (iAlg == 223) return iCoverageBalance + iLODevDiff + iProtThreatDiff + iCenterControlDiff;		/*		else		{			System.out.println("Funny algorithm.... movevalue.iCalcValue()");			return 0;		}				return iCoverageBalance;   */	}		boolean equals (movevalue mv2)	{		if (iPieceBalance != mv2.iPieceBalance) return false;		if (iCoverageBalance != mv2.iCoverageBalance) return false;		if (iPawnAdvBalance != mv2.iPawnAdvBalance) return false;				if (iProtThreatDiff != mv2.iProtThreatDiff) return false;		if (iCastledDiff != mv2.iCastledDiff) return false;		if (iLODevDiff != mv2.iLODevDiff) return false;				if (iDoublePawnDiff != mv2.iDoublePawnDiff) return false;		if (iCenterControlDiff != mv2.iCenterControlDiff) return false;				if (bWhiteCheckMate != mv2.bWhiteCheckMate) return false;		if (bWhiteChecked != mv2.bWhiteChecked) return false;		if (bWhiteBlocked != mv2.bWhiteBlocked) return false;				if (bBlackCheckMate != mv2.bBlackCheckMate) return false;		if (bBlackChecked != mv2.bBlackChecked) return false;		if (bBlackBlocked != mv2.bBlackBlocked) return false;				if (iMaxWhiteThreat != mv2.iMaxWhiteThreat) return false;		if (iMaxBlackThreat != mv2.iMaxBlackThreat) return false;				if (iMaxWhiteThrProtBal != mv2.iMaxWhiteThrProtBal) return false;		if (iMaxBlackThrProtBal != mv2.iMaxBlackThrProtBal) return false;				if (iKingCtrlDiff != mv2.iKingCtrlDiff) return false;				if (iEGPenDiff != mv2.iEGPenDiff) return false;		if (iKingSpaceDiff !=  mv2.iEGPenDiff) return false;				if (iFreePawnPointBal != mv2.iFreePawnPointBal) return false;				if (bEndGameMode != mv2.bEndGameMode) return false;		if (bKillModeQRwK != mv2.bKillModeQRwK) return false;		if (bPawnPromRace != mv2.bPawnPromRace) return false;			if (iKingDistanceBal != mv2.iKingDistanceBal) return false;				if (iPieceBalCorrWhite != mv2.iPieceBalCorrWhite) return false;		if (iPieceBalCorrBlack != mv2.iPieceBalCorrBlack) return false;			if (iValSumWhite != mv2.iValSumWhite) return false;		if (iValSumBlack != mv2.iValSumBlack) return false;				if (iFreePawnCtrlBal != mv2.iFreePawnCtrlBal) return false;				if (iWhiteCastlingMove != mv2.iWhiteCastlingMove) return false;		if (iBlackCastlingMove != mv2.iBlackCastlingMove) return false;				if (iCheckMoveBal != mv2.iCheckMoveBal) return false;				if (iMoveListLenghtBal != mv2.iMoveListLenghtBal) return false;		if (iQESBal != mv2.iQESBal) return false;				if (bWhiteInstWin != mv2.bWhiteInstWin) return false;		if (bBlackInstWin != mv2.bBlackInstWin) return false;				if (iInstWinCorr != mv2.iInstWinCorr) return false;				if (bWhiteRiskOn != mv2.bWhiteRiskOn) return false;		if (bBlackRiskOn != mv2.bBlackRiskOn) return false;				if (iKnightCoupBal != mv2.iKnightCoupBal) return false;		if (iKnightCoupMovBal != mv2.iKnightCoupMovBal) return false;				if (iPcsInEnemyBlockBal != mv2.iPcsInEnemyBlockBal) return false;				if (iWhiteMvLastProm != mv2.iWhiteMvLastProm) return false;		if (iBlackMvLastProm != mv2.iBlackMvLastProm) return false;				if (iPromBonWhite != mv2.iPromBonWhite) return false;		if (iPromBonBlack != mv2.iPromBonBlack) return false;				if (iPawnProtPenBal != mv2.iPawnProtPenBal) return false;				if (iKingCtrlFixBal != mv2.iKingCtrlFixBal) return false;				if (iSwapBal != mv2.iSwapBal) return false;		if (iEGSBal != mv2.iEGSBal) return false;				if (iCutBranchLevel != mv2.iCutBranchLevel) return false;				if (iQRKillBal != mv2.iQRKillBal);				return true;	}		boolean similarMates (movevalue mv2)	{		if (bWhiteCheckMate != mv2.bWhiteCheckMate) return false;        return bBlackCheckMate == mv2.bBlackCheckMate;			}		boolean mateCondition()	{        return bWhiteCheckMate || bBlackCheckMate;    }		String sMove()	{		if (sRoute.length() >= 5) return sRoute.substring(1,5);		else return null;	}		String sGuessNext()	{		if (sRoute.length() >= 10) return sRoute.substring(6,10);		else return null;	}		boolean isEqualMirror (movevalue mv2, int iAlg, int iTurn)	{		if (iPieceBalance != -mv2.iPieceBalance) return false;		if (bWhiteCheckMate != mv2.bBlackCheckMate) return false;		if (bWhiteChecked != mv2.bBlackChecked) return false;		if (bWhiteBlocked != mv2.bBlackBlocked) return false;        return iCalcValue(iAlg, iTurn) == -mv2.iCalcValue(iAlg, 1 - iTurn);    }		boolean mirrorMates(movevalue mv2)	{		if (!bWhiteCheckMate && !bBlackCheckMate) return false;		if (!mv2.bWhiteCheckMate && !mv2.bBlackCheckMate) return false;				if (bWhiteCheckMate && mv2.bBlackCheckMate) return true;        return mv2.bWhiteCheckMate && bBlackCheckMate;    }		int thrCorr(int iAlg, int iTurn, movevalue mv2)	{		int iThrCorr = 0;		int iThrDiff;				if (iAlg == ALG_AVOIDTHREAT)		{			if (1-iTurn == Piece.WHITE)   //  $$$ compare was with iColor 140413				iThrDiff = mv2.iMaxWhiteThreat - iMaxWhiteThreat ;			else iThrDiff = iMaxBlackThreat - mv2.iMaxBlackThreat;						iThrCorr = iThrDiff / 3;		}						if (1-iTurn == Piece.WHITE)  //  $$$ compare was with iColor 140413			iThrDiff = mv2.iMaxWhiteThrProtBal - iMaxWhiteThrProtBal;      // BLACK is threatening white		else iThrDiff = iMaxBlackThrProtBal - mv2.iMaxBlackThrProtBal;     // WHITE is threatening black				if (iAlg != ALG_KNIGHT_COUP)		{				//iThrCorr = iThrDiff / 3;  // change to max correction = +-1 140514			if (iThrDiff >= 3) iThrCorr = 1;			if (iThrDiff <= -3) iThrCorr = -1;		}		else		{			//System.out.println("DBG 141222 KC fix @ movevalue.thrCorr()");			if (iThrDiff >= 3) iThrCorr = 1;			if (iThrDiff >= 5) iThrCorr = 2;			if (iThrDiff >= 9) iThrCorr = 3;						if (iThrDiff <= -3) iThrCorr = -1;			if (iThrDiff <= -5) iThrCorr = -2;			if (iThrDiff <= -9) iThrCorr = -3;						//System.out.println("DBG 141222 KC fix @ movevalue.thrCorr() value(a):"+iThrCorr);			//System.out.println("DBG 141222 KC fix @ movevalue.thrCorr() KCB:" + iKnightCoupBal +  " mv2.KCB:" + mv2.iKnightCoupBal);						iThrCorr = iThrCorr + iKnightCoupBal;						//System.out.println("DBG 141222 KC fix @ movevalue.thrCorr() value(b):"+iThrCorr);		}				return iThrCorr;	}		int movevaluediff(movevalue mv2, int iTurn)	{		switch (iTurn)		{			case Piece.WHITE:				return iPieceBalCorrWhite - mv2.iPieceBalCorrWhite;							case Piece.BLACK:				return iPieceBalCorrBlack - mv2.iPieceBalCorrBlack;							default:				System.out.println("FATAL ERROR @movevalue.movevaluediff() bad color code.");				throw new RuntimeException("FATAL ERROR @movevalue.movevaluediff() bad color code.");		}	}		int movevaluediffInCheck(movevalue mv2, int iTurn)	{		/*		System.out.println("DBG150207: MVDIC called: iTurn=" + iTurn);		System.out.println("DBG150207: MVDIC Wthrprotbal: " + iMaxWhiteThrProtBal + " vs. " + mv2.iMaxWhiteThrProtBal);		System.out.println("DBG150207: MVDIC Bthrprotbal: " + iMaxBlackThrProtBal + " vs. " + mv2.iMaxBlackThrProtBal);		*/				switch (iTurn)		{			case Piece.WHITE:				return iPieceBalCorrWhite - mv2.iPieceBalCorrWhite - (int)Math.signum(iMaxWhiteThrProtBal-mv2.iMaxWhiteThrProtBal);							case Piece.BLACK:				return iPieceBalCorrBlack - mv2.iPieceBalCorrBlack - (int)Math.signum(mv2.iMaxBlackThrProtBal-iMaxBlackThrProtBal);							default:				System.out.println("FATAL ERROR @movevalue.movevaluediff() bad color code.");				throw new RuntimeException("FATAL ERROR @movevalue.movevaluediff() bad color code.");		}	}		boolean bDiffMoveByRoute (movevalue mv2)	{		if (mv2 == null) return true;        return !sRoute.equalsIgnoreCase(mv2.sRoute);	}		boolean equalStates(movevalue mv2)	{		if (bWhiteCheckMate != mv2.bWhiteCheckMate) return false;		if (bWhiteChecked != mv2.bWhiteChecked) return false;		if (bWhiteBlocked != mv2.bWhiteBlocked) return false;		if (bBlackCheckMate != mv2.bBlackCheckMate) return false;		if (bBlackChecked != mv2.bBlackChecked) return false;		if (bBlackBlocked != mv2.bBlackBlocked) return false;		if (bWhiteInstWin != mv2.bWhiteInstWin) return false;        return bBlackInstWin == mv2.bBlackInstWin;    }		String getFirstMove()	{		return sRoute.substring(1,5);	}		String getMoveN(int n)	{		//System.out.println("DBG160622: movevalue.getMoveN, n:"+n + " sRoute:"+sRoute);				String sComp[] = sRoute.split(";");		//for (int i=0;i<sComp.length;i++) System.out.println(i+":" + sComp[i]);		String sRet = null;				//if (n >= 0) return sRoute.substring(1+5*n,5+5*n);		//else return sRoute.substring(1,5);				return sComp[n+1];	}		int getComLength()	{		String sComp[] = sRoute.split(";");		return sComp.length-2;	}		void resetLastProms(movevalue mv2)	{		int iSeqLength = sRoute.length()/5;		int iLastPromLimit = iMoveCount/2 -iSeqLength-1;		if (iWhiteMvLastProm < iLastPromLimit) iWhiteMvLastProm = 0;		if (mv2.iWhiteMvLastProm < iLastPromLimit) mv2.iWhiteMvLastProm = 0;		if (iBlackMvLastProm < iLastPromLimit) iBlackMvLastProm = 0;		if (mv2.iBlackMvLastProm < iLastPromLimit) mv2.iBlackMvLastProm = 0;			}		void setInstWinnable(int iColor)	{		if (iColor == Piece.WHITE)		{			bWhiteInstWin = true;			bBlackInstWin = false;		}		else		{			bWhiteInstWin = false;			bBlackInstWin = true;			}			}		void setCutBranchLevel(int iLevel)	{		/*if (iLevel == 2) 		{			System.out.println("at movevalue.setCutBranchLevel(2)");		}		*/		iCutBranchLevel = iLevel;	}		int getCutBranchLevel()	{		return iCutBranchLevel;	}		int getCorrPieceBal(int iTurn)	{		if (iTurn == Piece.WHITE) return iPieceBalCorrBlack;		else return iPieceBalCorrWhite;	}}